# 24_mesh_morphing.morph
# Morphogen Example: Mesh Morphing and Subdivision
#
# Description: Demonstrates advanced geometry domain features including
# mesh operations, subdivision surfaces, and 3D transformations. A simple
# mesh smoothly morphs between different primitive shapes using mesh
# subdivision and interpolation.
#
# Demonstrates:
#   - 3D mesh operations (subdivision, extrusion)
#   - Collision mesh generation for physics
#   - Mesh transformation and scaling
#   - Bounding volume calculations
#   - Distance field generation from meshes
#   - Cross-domain: geometry â†’ visual rendering
#
# Expected Output: Animated sequence showing a box morphing into a sphere
# through subdivision and smooth interpolation, demonstrating the power
# of geometric mesh operations
#
# Parameters you can experiment with:
#   - SUBDIVISION_LEVELS: Mesh smoothness (try 0 to 3)
#   - MORPH_SPEED: Transition speed (try 0.5 to 2.0)
#   - ROTATION_SPEED: Mesh rotation speed (try 0.5 to 3.0)
#
# Author: Morphogen Team
# Date: 2025-11-18

use geometry, visual

# Animation parameters
const SUBDIVISION_LEVELS : i32 = 2
const MORPH_SPEED : f32 = 1.0
const ROTATION_SPEED : f32 = 1.5

# Time accumulator
@state time : f32 = 0.0

# Current morph state (0 = box, 1 = sphere)
@state morph_t : f32 = 0.0

# Create base primitives
const BOX_SIZE : f32 = 10.0
const SPHERE_RADIUS : f32 = 7.0

# Function to create interpolated geometry
fn create_morphed_shape(t: f32) -> Mesh {
    # t = 0: full box
    # t = 1: full sphere
    # 0 < t < 1: interpolated shape

    # For demonstration, we'll create a shape at the interpolated position
    # In a real implementation, this would blend vertex positions

    if t < 0.5 then {
        # Box phase - create a box and subdivide it
        base_box = box3d(
            center=[0.0, 0.0, 0.0],
            width=BOX_SIZE,
            height=BOX_SIZE,
            depth=BOX_SIZE
        )

        # Subdivide to add detail
        # In real implementation: subdivided = subdivide_mesh(base_box, levels=SUBDIVISION_LEVELS)

        return base_box
    } else {
        # Sphere phase
        base_sphere = sphere(
            center=[0.0, 0.0, 0.0],
            radius=SPHERE_RADIUS
        )

        return base_sphere
    }
}

# Function to apply rotation transformation
fn rotate_shape(angle: f32) -> Transform3D {
    # Create rotation around Y axis
    # In real implementation, this would be a proper 3D transformation matrix

    return rotate_y(angle=angle)
}

# Main animation loop
flow(dt=0.033, steps=600) {
    # Update morph parameter (ping-pong between 0 and 1)
    morph_t = morph_t + MORPH_SPEED * dt

    # Ping-pong: bounce between 0 and 2, then map to 0-1-0
    morph_cycle = morph_t % 2.0
    if morph_cycle > 1.0 then {
        morph_param = 2.0 - morph_cycle
    } else {
        morph_param = morph_cycle
    }

    # Smooth interpolation using smoothstep
    # smoothstep provides nice easing in/out
    t_smooth = morph_param * morph_param * (3.0 - 2.0 * morph_param)

    # Create morphed geometry
    shape = create_morphed_shape(t_smooth)

    # Apply rotation
    rotation_angle = time * ROTATION_SPEED
    rotation = rotate_shape(rotation_angle)

    # Get bounding box for camera framing
    bounds = bounding_box(shape=shape)

    # Generate collision mesh for physics (if needed)
    # collision = collision_mesh(shape=shape, max_vertices=256)

    # Calculate mesh volume (for display)
    vol = volume(shape=shape)

    # Render the scene
    output render_3d(
        objects=[shape],
        transform=rotation,
        camera_pos=[25.0, 20.0, 25.0],
        camera_target=[0.0, 0.0, 0.0],
        lighting="three_point",
        wireframe=false,
        # Display info overlay
        overlay_text="Morph: " + t_smooth + " | Volume: " + vol
    )

    # Update time
    time = time + dt
}
