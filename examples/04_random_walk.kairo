# 04_random_walk.kairo
# Kairo Example: Random Walk - Brownian Motion Patterns
#
# Description: Watch random walkers create beautiful diffusion patterns
# as they accumulate in a density field, demonstrating emergent behavior
# from simple stochastic rules.
#
# Demonstrates:
#   - Random number generation with determinism
#   - State accumulation over time
#   - Random field operations
#   - Emergence of diffusion patterns from random walks
#
# Expected Output: Gaussian-like density distribution emerges from
# random walks, creating smooth colorful patterns from random motion
#
# Parameters you can experiment with:
#   - NUM_WALKERS: Number of random walkers (try 100 to 1000)
#   - steps: Simulation duration (try 1000 to 5000)
#   - Random walk step size (currently fixed at 1)
#
# Author: Kairo Team
# Date: 2025-11-07

use field, visual

# Number of random walkers
const NUM_WALKERS : i32 = 500

# Density field to accumulate walker positions
@state density : Field2D<f32> = field.alloc((128, 128), fill_value=0.0)

# Walker positions (initialized at center)
@state walker_x : Field1D<f32> = field.alloc((NUM_WALKERS,), fill_value=1.0) * 64.0
@state walker_y : Field1D<f32> = field.alloc((NUM_WALKERS,), fill_value=1.0) * 64.0

# Random seed for reproducibility
@state seed : i32 = 42

# Initialize walkers at center
fn init_walkers() {
    # All walkers start at the center
    walker_x = field.alloc((NUM_WALKERS,), fill_value=1.0) * 64.0
    walker_y = field.alloc((NUM_WALKERS,), fill_value=1.0) * 64.0
}

init_walkers()

# Main simulation loop
flow(dt=1.0, steps=2000) {
    # Each walker takes a random step
    for i in 0..NUM_WALKERS {
        # Generate random direction (-1 or 1 for each axis)
        # Using simple hash-based RNG for determinism
        rand_val_x = hash(seed + i * 2 + step * NUM_WALKERS * 2) % 3 - 1  # -1, 0, or 1
        rand_val_y = hash(seed + i * 2 + step * NUM_WALKERS * 2 + 1) % 3 - 1

        # Update walker position
        walker_x[i] = walker_x[i] + rand_val_x
        walker_y[i] = walker_y[i] + rand_val_y

        # Boundary conditions (wrap around)
        walker_x[i] = (walker_x[i] + 128.0) % 128.0
        walker_y[i] = (walker_y[i] + 128.0) % 128.0

        # Accumulate density at walker position
        ix = floor(walker_x[i])
        iy = floor(walker_y[i])
        density[iy, ix] = density[iy, ix] + 1.0
    }

    # Apply slight diffusion to smooth the density field
    density = diffuse(density, rate=0.05, dt, iterations=5)

    # Normalize and visualize
    max_density = max(density)
    normalized = density / max(max_density, 1.0)

    output colorize(normalized, palette="viridis", min=0.0, max=1.0)
}
