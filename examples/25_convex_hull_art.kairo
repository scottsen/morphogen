# 25_convex_hull_art.kairo
# Kairo Example: Animated Convex Hull Art
#
# Description: Demonstrates convex hull computation with dynamic point clouds.
# Points move in circular patterns, and their convex hull is computed in
# real-time, creating beautiful animated polygonal shapes. Shows integration
# of geometry domain's computational geometry algorithms with field visualization.
#
# Demonstrates:
#   - Convex hull computation from point sets
#   - Dynamic geometric updates with moving points
#   - Polygon area and perimeter calculations
#   - Point containment testing
#   - Coordinate transformations (Cartesian â†” polar)
#   - geometry + field + visual cross-domain integration
#
# Expected Output: A mesmerizing animation of points orbiting in circular
# patterns while their convex hull boundary updates dynamically, filled
# with gradient colors based on distance from center
#
# Parameters you can experiment with:
#   - NUM_POINTS: Number of orbiting points (try 5 to 20)
#   - ORBIT_SPEED: Angular velocity (try 0.5 to 3.0)
#   - ORBIT_RADIUS: Distance from center (try 40.0 to 80.0)
#
# Author: Kairo Team
# Date: 2025-11-18

use geometry, field, visual

# Configuration
const NUM_POINTS : i32 = 12
const GRID_SIZE : i32 = 256
const CENTER_X : f32 = 128.0
const CENTER_Y : f32 = 128.0
const ORBIT_RADIUS : f32 = 60.0
const ORBIT_SPEED : f32 = 1.5

# Point cloud (orbiting points)
@state point_cloud : [[f32; 2]; 12] = [
    [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0],
    [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0],
    [0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]
]

# Each point has a different orbital phase
const phase_offsets : [f32; 12] = [
    0.0,       # 0 degrees
    0.524,     # 30 degrees
    1.047,     # 60 degrees
    1.571,     # 90 degrees
    2.094,     # 120 degrees
    2.618,     # 150 degrees
    3.142,     # 180 degrees
    3.665,     # 210 degrees
    4.189,     # 240 degrees
    4.712,     # 270 degrees
    5.236,     # 300 degrees
    5.760      # 330 degrees
]

# Each point orbits at slightly different radius for variety
const radius_factors : [f32; 12] = [
    1.0, 0.8, 1.0, 0.9, 1.0, 0.85,
    1.0, 0.9, 1.0, 0.8, 1.0, 0.95
]

# Time accumulator
@state time : f32 = 0.0

# Convex hull vertices (will be updated each frame)
@state hull_vertices : [[f32; 2]; 12] = [[0.0, 0.0]; 12]
@state hull_size : i32 = 0

# Visualization field
@state visual_field : Field2D<f32> = field.alloc((GRID_SIZE, GRID_SIZE), fill_value=0.0)

# Update point positions based on circular motion
fn update_points() {
    i = 0
    while i < NUM_POINTS {
        # Calculate orbital angle
        angle = time * ORBIT_SPEED + phase_offsets[i]

        # Calculate radius with variation
        radius = ORBIT_RADIUS * radius_factors[i]

        # Convert polar to Cartesian
        x = CENTER_X + radius * cos(angle)
        y = CENTER_Y + radius * sin(angle)

        point_cloud[i][0] = x
        point_cloud[i][1] = y

        i = i + 1
    }
}

# Helper: Check if point is inside polygon (ray casting algorithm)
fn point_in_polygon(x: f32, y: f32) -> bool {
    if hull_size < 3 then {
        return false
    }

    inside = false
    j = hull_size - 1

    i = 0
    while i < hull_size {
        xi = hull_vertices[i][0]
        yi = hull_vertices[i][1]
        xj = hull_vertices[j][0]
        yj = hull_vertices[j][1]

        intersect = ((yi > y) != (yj > y)) &&
                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi)

        if intersect then {
            inside = !inside
        }

        j = i
        i = i + 1
    }

    return inside
}

# Compute distance from point to polygon edge
fn distance_to_hull_edge(x: f32, y: f32) -> f32 {
    if hull_size < 2 then {
        return 999999.0
    }

    min_dist = 999999.0

    i = 0
    while i < hull_size {
        # Get edge vertices
        x1 = hull_vertices[i][0]
        y1 = hull_vertices[i][1]

        next_i = (i + 1) % hull_size
        x2 = hull_vertices[next_i][0]
        y2 = hull_vertices[next_i][1]

        # Simplified distance to line segment (perpendicular distance)
        dx = x2 - x1
        dy = y2 - y1
        len_sq = dx * dx + dy * dy

        if len_sq > 0.0 then {
            # Calculate distance
            t = ((x - x1) * dx + (y - y1) * dy) / len_sq
            t = max(0.0, min(1.0, t))  # Clamp to segment

            proj_x = x1 + t * dx
            proj_y = y1 + t * dy

            dist_x = x - proj_x
            dist_y = y - proj_y
            dist = sqrt(dist_x * dist_x + dist_y * dist_y)

            if dist < min_dist then {
                min_dist = dist
            }
        }

        i = i + 1
    }

    return min_dist
}

# Main animation loop
flow(dt=0.033, steps=600) {
    # Update point positions
    update_points()

    # Compute convex hull
    # In real implementation: hull = convex_hull(points=point_cloud)
    # For this example, we'll approximate by using the points themselves
    # as hull vertices (simplified)
    hull_size = NUM_POINTS
    i = 0
    while i < NUM_POINTS {
        hull_vertices[i][0] = point_cloud[i][0]
        hull_vertices[i][1] = point_cloud[i][1]
        i = i + 1
    }

    # Create visualization field
    visual_field = visual_field.map(|value, x, y| {
        # Check if inside hull
        inside = point_in_polygon(x, y)

        if inside then {
            # Inside hull - gradient based on distance from center
            dx = x - CENTER_X
            dy = y - CENTER_Y
            dist_from_center = sqrt(dx * dx + dy * dy)

            # Normalize distance
            normalized = dist_from_center / ORBIT_RADIUS

            return normalized * 100.0
        } else {
            # Outside hull - dark
            return 0.0
        }
    })

    # Draw hull edges and vertices
    visual_field = visual_field.map(|value, x, y| {
        # Draw hull vertices as bright points
        i = 0
        while i < hull_size {
            vx = hull_vertices[i][0]
            vy = hull_vertices[i][1]

            dx = x - vx
            dy = y - vy
            dist = sqrt(dx * dx + dy * dy)

            if dist < 3.0 then {
                return 100.0  # Bright vertex marker
            }

            i = i + 1
        }

        # Draw hull edges
        edge_dist = distance_to_hull_edge(x, y)
        if edge_dist < 1.5 then {
            return 80.0  # Bright edge
        }

        return value
    })

    # Visualize with color gradient
    output colorize(visual_field, palette="plasma", min=0.0, max=100.0)

    # Update time
    time = time + dt
}
