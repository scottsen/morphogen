# Morphogen Core v0.1 Implementation Roadmap

**Version:** 1.0
**Status:** Active Development
**Last Updated:** 2025-11-13
**Timeline:** 12 weeks (Weeks 1-12)

---

## Executive Summary

This roadmap defines the critical path for implementing **Morphogen Core v0.1** â€” the foundational kernel layer that all higher-level features (audio, physics, visuals, ML) depend on. If these components are correct, everything else becomes easy, extensible, and composable. If they are wrong, everything becomes fragile.

**Guiding Philosophy:** Get the base layer perfect first. Avoid scope creep. Defer domain libraries until v0.2+.

---

## Current State (v0.3.1)

### âœ… What Exists (Strong Foundation)
- **Language Frontend:** Lexer, parser, AST (v0.3.1 complete)
- **Runtime:** Python interpreter with functions, lambdas, closures, structs
- **MLIR Compiler:** All 5 phases implemented (text IR generation)
- **Field Operations:** advect, diffuse, project, laplacian, gradient, divergence
- **Visual Operations:** colorize, PNG/JPEG export
- **Documentation:** ../specifications/graph-ir.md, ../specifications/transform.md, architecture.md
- **Test Suite:** 275+ tests (~232 passing)

### âŒ What's Missing (Critical Gaps)
1. **Type System & Units System** â€” No runtime unit checking or arithmetic
2. **Profile System** â€” No strict/repro/live implementation
3. **Deterministic Multirate Scheduler** â€” No rate partitioning, fencing, or LCM scheduling
4. **Operator Registry** â€” No declarative operator metadata or lowering hints
5. **Graph IR Implementation** â€” Spec exists, but no parser/validator code
6. **MLIR Dialects** â€” No morphogen.stream, morphogen.field, morphogen.transform, morphogen.schedule dialects
7. **Snapshot ABI & Hot Reload** â€” No state serialization or hot reload support

---

## Guiding Principles (The North Star)

Every design decision must satisfy these **5 principles:**

1. **One semantic kernel** â€” Single source of truth for time, space, units, determinism, profiles, types
2. **First-class transforms** â€” Domain changes (FFT, etc.) are explicit and typed, not special cases
3. **Typed, deterministic computation** â€” Every signal/field/event has type, domain, rate, units, determinism tier
4. **Thin, replaceable backends** â€” Kernel logic stays pure; providers perform execution
5. **Two surfaces share IR** â€” Morphogen.Audio + RiffStack both emit the same Graph IR

---

## 12-Week Implementation Plan

### **Weeks 1-2: Formal Specification** ğŸ¯ CURRENT PHASE

**Objective:** Lock down the semantics for all 7 core components.

**Deliverables:**
- [ ] `../specifications/type-system.md` â€” Core types, Stream<T,D,R>, Field<T,D>, Evt<A>, Grid<Dim,Spacing,Centering>
- [ ] `../specifications/units.md` â€” SI units, audio units (Hz, dB, cents), visual units (px, sr), physics units (m, N)
- [ ] `../specifications/profiles.md` â€” strict/repro/live profiles with FP behavior, block size, FFT norms, RNG
- [ ] `../specifications/scheduler.md` â€” Multirate scheduling, sample-accurate fences, LCM partitioning, resampling
- [ ] `../specifications/operator-registry.md` â€” Operator schema, metadata fields, lowering templates, codegen
- [ ] `../specifications/snapshot-abi.md` â€” State serialization, buffer semantics, hot reload protocol
- [ ] `../../specifications/mlir-dialects.md` â€” morphogen.stream, morphogen.field, morphogen.transform, morphogen.schedule ops

**Success Criteria:**
- All specifications include formal invariants
- Sanity-checked with small manual examples
- No ambiguities or unresolved design questions

---

### **Weeks 3-5: Operator Registry + Graph IR**

**Objective:** Implement the "single source of truth" for operators and graph validation.

**Deliverables:**
- [ ] `morphogen/registry/` â€” Operator registry parser (JSON schema)
- [ ] `morphogen/registry/operators.json` â€” Core operator definitions (50+ ops)
- [ ] `morphogen/graph/` â€” Graph IR parser, validator, type checker
- [ ] `morphogen/graph/validate.py` â€” Type checking, DAG validation, rate compatibility, unit checking
- [ ] `morphogen/codegen/` â€” Stub generator for kernel implementations
- [ ] Unit tests for registry + graph validation

**Success Criteria:**
- Parse and validate example Graph IR (simple synth)
- Detect type mismatches, unit errors, cycles
- Generate operator stubs for Python and MLIR

---

### **Weeks 6-8: Multirate Scheduler Core**

**Objective:** Implement deterministic, multirate execution with sample-accurate fencing.

**Deliverables:**
- [ ] `morphogen/scheduler/` â€” Multirate scheduler implementation
- [ ] `morphogen/scheduler/partition.py` â€” LCM-based rate partitioning
- [ ] `morphogen/scheduler/fence.py` â€” Sample-accurate event fencing
- [ ] `morphogen/scheduler/resample.py` â€” Cross-rate resampling (linear, cubic, sinc)
- [ ] `morphogen/scheduler/executor.py` â€” Double-buffered execution engine
- [ ] Unit tests for scheduler correctness and determinism

**Success Criteria:**
- Schedule mixed-rate graph (audio 48kHz, control 1kHz, visual 60Hz)
- Events fire at exact sample boundaries
- Bit-exact determinism across runs

---

### **Weeks 9-12: MLIR Dialects + Lowering**

**Objective:** Define core MLIR dialects and lower simple graphs to executable code.

**Deliverables:**
- [ ] `morphogen/mlir/dialects/stream.py` â€” morphogen.stream dialect (stream ops, sample, delay, mix)
- [ ] `morphogen/mlir/dialects/field.py` â€” morphogen.field dialect (field ops, stencil, reduce, map)
- [ ] `morphogen/mlir/dialects/transform.py` â€” morphogen.transform dialect (fft, ifft, stft, istft)
- [ ] `morphogen/mlir/dialects/schedule.py` â€” morphogen.schedule dialect (rate, fence, resample)
- [ ] `morphogen/mlir/lowering/` â€” Lowering to affine, linalg, vector, arith
- [ ] `morphogen/backends/cpu.py` â€” Minimal CPU backend (FFTW/Ooura stub)
- [ ] End-to-end test: compile + run simple Graph IR

**Success Criteria:**
- Compile simple synth (sine â†’ lpf â†’ pan) to executable
- Run and produce audio output
- Verify deterministic execution

---

## Base Features (Strict Requirements)

These **10 requirements** must be correct in v0.1:

1. âœ… **Deterministic execution** â€” Bit-exact results across runs
2. âœ… **Stable event timing** â€” Sample-accurate fencing
3. âœ… **Error-tight transforms** â€” FFT normalization modes explicit
4. âœ… **Strict profile behavior** â€” Profile semantics locked down
5. âœ… **No silent unit mismatches** â€” Compile-time unit validation
6. âœ… **Predictable lowering semantics** â€” MLIR lowering is deterministic
7. âœ… **Reproducible randomness** â€” Philox RNG with explicit seeding
8. âœ… **Safe hot reload** â€” State snapshots + graph hash validation
9. âœ… **Accurate type inference** â€” Graph IR type inference works
10. âœ… **Clear domain transform semantics** â€” Transform ops have explicit domain metadata

---

## Out of Scope (v0.2+)

**DO NOT LET THESE DISTRACT YOU:**

- âŒ Fancy PDE solvers (beyond basic diffusion/advection)
- âŒ Physics libraries (N-body, SPH, FEM)
- âŒ Visuals beyond basic field colorization
- âŒ Tree codes (Barnes-Hut, FMM)
- âŒ Particle-grid transforms
- âŒ GPU backend optimization (beyond stubs)
- âŒ Morphogen.Audio advanced features (reverb, convolution, etc.)
- âŒ RiffStack advanced controls (looper, RPN expressions)
- âŒ Adaptive integrators
- âŒ Caching layers
- âŒ Distributed execution
- âŒ Audio device integration (JACK, ASIO, CoreAudio)
- âŒ UI tooling (web editor, graph visualizer)
- âŒ Documentation polish (beyond specs)

---

## Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Frontend Surfaces                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Morphogen.Audio DSL â”‚              â”‚  RiffStack YAML  â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚           â”‚                                  â”‚              â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                          â–¼                                  â”‚
â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚                â”‚   Graph IR (JSON)â”‚                         â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Morphogen Kernel (v0.1)                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  1. Type System & Units                              â”‚  â”‚
â”‚  â”‚  2. Profile System (strict/repro/live)               â”‚  â”‚
â”‚  â”‚  3. Operator Registry                                â”‚  â”‚
â”‚  â”‚  4. Graph IR Parser & Validator                      â”‚  â”‚
â”‚  â”‚  5. Multirate Scheduler                              â”‚  â”‚
â”‚  â”‚  6. MLIR Dialects (stream, field, transform, schedule) â”‚  â”‚
â”‚  â”‚  7. Snapshot ABI & Hot Reload                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Execution Backends                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   CPU    â”‚  â”‚   GPU    â”‚  â”‚   WASM   â”‚  â”‚  WebGPU  â”‚   â”‚
â”‚  â”‚ (LLVM)   â”‚  â”‚ (CUDA)   â”‚  â”‚          â”‚  â”‚          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Milestone Checklist

### Phase 1: Specification (Weeks 1-2)
- [ ] All 7 specs written and reviewed
- [ ] Invariants documented with examples
- [ ] No unresolved design questions

### Phase 2: Registry + Graph IR (Weeks 3-5)
- [ ] Operator registry parses 50+ operators
- [ ] Graph IR validator catches type/unit/DAG errors
- [ ] Stub generator produces Python + MLIR code

### Phase 3: Scheduler (Weeks 6-8)
- [ ] Multirate scheduling works (audio/control/visual)
- [ ] Events fire at exact sample boundaries
- [ ] Determinism verified with golden tests

### Phase 4: MLIR + Backend (Weeks 9-12)
- [ ] Core dialects defined (stream, field, transform, schedule)
- [ ] Lowering to affine/linalg/vector works
- [ ] End-to-end: compile simple synth, produce audio

---

## Success Metrics

1. **Specification completeness** â€” All 7 specs written, no ambiguities
2. **Type safety** â€” Graph IR rejects invalid graphs (type/unit/DAG)
3. **Determinism** â€” Bit-exact results across runs (strict profile)
4. **Scheduler correctness** â€” Mixed-rate graphs execute correctly
5. **MLIR integration** â€” Simple graphs lower to executable code
6. **Test coverage** â€” All core components have unit + integration tests

---

## Risk Mitigation

### High Risk: Multirate Scheduler Complexity
- **Mitigation:** Start with simple 2-rate case (audio + control), expand later
- **Fallback:** Single-rate execution only for v0.1

### Medium Risk: MLIR Dialect Design
- **Mitigation:** Keep dialects minimal, avoid exotic ops
- **Fallback:** Text IR generation only (defer real MLIR bindings to v0.2)

### Low Risk: Operator Registry Schema
- **Mitigation:** Use existing JSON schema, leverage TypeScript-style validation
- **Fallback:** Simplified schema, defer advanced metadata to v0.2

---

## Next Steps (Immediate)

1. âœ… Read existing architecture docs
2. âœ… Create this roadmap document
3. **NOW:** Begin writing specifications (Weeks 1-2)
4. **Week 3:** Implement operator registry + graph IR
5. **Week 6:** Implement multirate scheduler
6. **Week 9:** Implement MLIR dialects + lowering

---

## One-Sentence Summary

**Morphogen Core v0.1 is the foundational kernel layer â€” type system, units, profiles, scheduler, operator registry, Graph IR, MLIR dialects, and snapshot ABI â€” that makes everything else (audio, physics, visuals, ML) easy and composable.**

---

## References

- `../specifications/graph-ir.md` â€” Graph IR specification
- `../specifications/transform.md` â€” Transform dialect specification
- `architecture.md` â€” Overall Morphogen architecture
- Blueprint document (this conversation) â€” Core v0.1 requirements

---

**Status:** Ready to begin Weeks 1-2 (Specification Phase)
