# Morphogen v0.7.0 Design: Real MLIR Integration

**Version**: 0.7.0
**Status**: Phase 3 Complete - Temporal Execution ✅
**Timeline**: 12+ months
**Started**: 2025-11-14
**Phase 2 Completed**: 2025-11-14
**Phase 3 Completed**: 2025-11-14

---

## Executive Summary

Morphogen v0.7.0 represents a fundamental transformation from text-based MLIR IR generation to **real MLIR integration** using Python bindings. This enables true native code generation, optimization passes, and JIT compilation.

### Current State (v0.6.0)
- ✅ Text-based MLIR-like IR generation via custom Python classes
- ✅ String template output that mimics MLIR syntax
- ✅ Basic optimization passes on custom IR data structures
- ❌ No actual MLIR C++ API integration
- ❌ No real dialect registration or lowering
- ❌ No code generation or execution

### Target State (v0.7.0)
- ✅ Real MLIR Python bindings integration
- ✅ Custom Morphogen dialects registered in MLIR
- ✅ Proper lowering passes (Morphogen → SCF/Arith → LLVM)
- ✅ LLVM code generation and JIT compilation
- ✅ Native execution of field operations

---

## Architecture Overview

### 1. MLIR Integration Layers

```
┌─────────────────────────────────────────────────┐
│           Morphogen DSL Frontend (v0.6.0)           │
│         Parser → AST → Type Checker             │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────┐
│        MLIR Dialect Layer (NEW in v0.7.0)       │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ Morphogen.Field  │  │ Morphogen.Agent  │            │
│  │  Dialect     │  │   Dialect    │            │
│  └──────────────┘  └──────────────┘            │
│  ┌──────────────┐  ┌──────────────┐            │
│  │ Morphogen.Audio  │  │ Morphogen.Visual │            │
│  │  Dialect     │  │   Dialect    │            │
│  └──────────────┘  └──────────────┘            │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────┐
│       Lowering Passes (NEW in v0.7.0)           │
│  Morphogen Dialects → SCF/Arith/Func → LLVM        │
│  - Field operations → vectorized loops          │
│  - State management → memref operations         │
│  - Temporal flow → structured control flow      │
└────────────────────┬────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────┐
│      LLVM Backend (NEW in v0.7.0)               │
│  Code Generation → Optimization → JIT/AOT       │
│  - LLVM IR generation                           │
│  - Target-specific optimization                 │
│  - Native code execution                        │
└─────────────────────────────────────────────────┘
```

### 2. Module Structure

```
morphogen/
├── mlir/                          # MLIR Integration (v0.7.0)
│   ├── __init__.py                # Public API
│   ├── context.py                 # MLIR Context management
│   ├── dialects/                  # Custom Morphogen dialects
│   │   ├── __init__.py
│   │   ├── field.py               # Field operations dialect
│   │   ├── agent.py               # Agent operations dialect
│   │   ├── audio.py               # Audio operations dialect
│   │   └── visual.py              # Visual operations dialect
│   ├── lowering/                  # Lowering passes
│   │   ├── __init__.py
│   │   ├── field_to_scf.py        # Field → SCF lowering
│   │   ├── scf_to_llvm.py         # SCF → LLVM lowering
│   │   └── optimization.py        # MLIR optimization passes
│   ├── codegen/                   # Code generation
│   │   ├── __init__.py
│   │   ├── jit.py                 # JIT compilation engine
│   │   └── aot.py                 # AOT compilation
│   ├── compiler.py                # Main compiler (refactored)
│   ├── ir_builder.py              # DEPRECATED - Legacy IR builder
│   └── optimizer.py               # DEPRECATED - Legacy optimizer
├── ast/                           # AST (unchanged)
├── parser/                        # Parser (unchanged)
└── runtime/                       # Runtime (enhanced for native code)
```

---

## Phase 1: Foundation (Months 1-3)

### Goals
- Set up MLIR Python bindings
- Create basic infrastructure
- Implement proof-of-concept for simple arithmetic

### Tasks

#### 1.1 MLIR Installation and Setup
```python
# requirements.txt
mlir>=18.0.0  # From mlir-wheels or built from source
numpy>=1.24.0
```

#### 1.2 Context Management (`morphogen/mlir/context.py`)
```python
from mlir import ir

class KairoMLIRContext:
    """Manages MLIR context for Morphogen compilation."""

    def __init__(self):
        self.ctx = ir.Context()
        self._register_dialects()

    def _register_dialects(self):
        """Register standard and custom dialects."""
        # Load standard dialects
        self.ctx.load_dialect("builtin")
        self.ctx.load_dialect("func")
        self.ctx.load_dialect("arith")
        self.ctx.load_dialect("scf")
        self.ctx.load_dialect("memref")

        # TODO: Register custom Morphogen dialects
```

#### 1.3 Basic IR Builder (`morphogen/mlir/compiler.py` - refactored)
```python
from mlir import ir
from mlir.dialects import builtin, func, arith

class MLIRCompilerV2:
    """MLIR compiler using real Python bindings."""

    def __init__(self, context: KairoMLIRContext):
        self.context = context
        self.module = ir.Module.create()

    def compile_literal(self, value: float) -> ir.Value:
        """Compile literal using arith.constant."""
        with self.context.ctx:
            return arith.ConstantOp(
                ir.F32Type.get(),
                ir.FloatAttr.get(ir.F32Type.get(), value)
            ).result
```

#### 1.4 Proof of Concept: Simple Arithmetic
Goal: Compile `x = 3.0 + 4.0` to real MLIR, lower to LLVM, execute via JIT.

```python
# Target MLIR output:
"""
module {
  func.func @main() -> f32 {
    %c3 = arith.constant 3.0 : f32
    %c4 = arith.constant 4.0 : f32
    %result = arith.addf %c3, %c4 : f32
    func.return %result : f32
  }
}
"""
```

---

## Phase 2: Field Operations (Months 4-6)

### Goals
- Implement Field dialect for spatial operations
- Support basic field operations (gradients, diffusion)
- Implement lowering to SCF loops

### Field Dialect Operations

```mlir
// High-level Morphogen Field operations
%field = morphogen.field.create %width, %height : !morphogen.field<f32>
%gradient = morphogen.field.gradient %field, %direction : !morphogen.field<f32>
%diffused = morphogen.field.diffuse %field, %rate : !morphogen.field<f32>

// Lowers to SCF loops:
scf.for %i = %c0 to %height step %c1 {
  scf.for %j = %c0 to %width step %c1 {
    // Field operation body
  }
}
```

### Implementation Strategy
1. Define Field type: `!morphogen.field<element_type, dimensions>`
2. Implement field operations as MLIR ops
3. Create lowering pass: `FieldToSCFPass`
4. Optimize with vectorization passes

### Phase 2 Deliverables ✅ COMPLETE (2025-11-14)

**Implemented:**
- ✅ `morphogen/mlir/dialects/field.py` - Complete field dialect with 4 operations
  - `FieldCreateOp`: Allocate fields with dimensions and fill value
  - `FieldGradientOp`: Central difference gradient computation
  - `FieldLaplacianOp`: 5-point stencil Laplacian
  - `FieldDiffuseOp`: Jacobi diffusion solver
- ✅ `morphogen/mlir/lowering/field_to_scf.py` - Full lowering pass implementation
  - Transforms field ops → nested scf.for loops + memref operations
  - Handles boundary conditions and stencil operations
  - Double-buffering for iterative solvers
- ✅ `morphogen/mlir/compiler_v2.py` - Extended compiler with field support
  - `compile_field_create/gradient/laplacian/diffuse` methods
  - `apply_field_lowering` pass integration
  - `compile_field_program` convenience API
- ✅ `tests/test_field_dialect.py` - Comprehensive test suite
  - Unit tests for all field operations
  - Integration tests for chained operations
  - Coverage for various field sizes and configurations
- ✅ `examples/phase2_field_operations.py` - Working examples
  - Field creation, gradient, Laplacian, diffusion examples
  - Combined operations demonstration
  - Full compilation pipeline showcase
- ✅ `benchmarks/field_operations_benchmark.py` - Performance benchmarking
  - Compilation time measurements
  - IR size and complexity metrics
  - Scalability analysis across field sizes

**Success Metrics:**
- ✅ All field operations compile to valid MLIR
- ✅ Lowering produces correct SCF loop structures
- ✅ Compilation time < 1s for typical programs
- ✅ Full test coverage with MLIR bindings
- ✅ Documentation and examples complete

**Ready for Phase 3**: Temporal execution and flow blocks

---

## Phase 3: Temporal Execution (Months 7-9)

### Goals
- Implement `flow` block compilation to real MLIR
- Support state management via memref
- Integrate temporal iteration

### Flow Block Lowering

```morphogen
@state x: f32 = 0.0

flow(dt=0.1, steps=10) {
    x = x + dt
}
```

Compiles to:

```mlir
%mem_x = memref.alloc() : memref<1xf32>
memref.store %c0, %mem_x[%c0] : memref<1xf32>

scf.for %iv = %c0 to %c10 step %c1 {
    %x = memref.load %mem_x[%c0] : memref<1xf32>
    %new_x = arith.addf %x, %dt : f32
    memref.store %new_x, %mem_x[%c0] : memref<1xf32>
}
```

### Phase 3 Deliverables ✅ COMPLETE (2025-11-14)

**Implemented:**
- ✅ `morphogen/mlir/dialects/temporal.py` - Complete temporal dialect with 6 operations
  - `FlowCreateOp`: Define flow blocks with dt and timestep count
  - `FlowStepOp`: Single timestep execution (placeholder for future)
  - `FlowRunOp`: Execute complete flow for N timesteps
  - `StateCreateOp`: Allocate persistent state containers
  - `StateUpdateOp`: Update state values (SSA-compatible)
  - `StateQueryOp`: Read current state values
- ✅ `morphogen/mlir/lowering/temporal_to_scf.py` - Full temporal lowering pass
  - Transforms flow.run → scf.for loops with iter_args
  - State.create → memref.alloc + initialization loops
  - State.update → memref.store operations
  - State.query → memref.load operations
- ✅ `morphogen/mlir/compiler_v2.py` - Extended compiler with temporal support
  - `compile_flow_create/run` methods
  - `compile_state_create/update/query` methods
  - `apply_temporal_lowering` pass integration
  - `compile_temporal_program` convenience API
- ✅ `tests/test_temporal_dialect.py` - Comprehensive test suite
  - Unit tests for all temporal operations
  - Integration tests with lowering passes
  - Compiler integration tests
  - Coverage for state management and flow execution
- ✅ `examples/phase3_temporal_execution.py` - Working examples
  - State creation and management
  - Flow execution with timesteps
  - State update/query operations
  - Combined field + temporal operations
- ✅ Documentation updates
  - v0.7.0_DESIGN.md updated with Phase 3 status
  - PHASE3_COMPLETION_SUMMARY.md created
  - STATUS.md updated
  - CHANGELOG.md updated

**Success Metrics:**
- ✅ All temporal operations compile to valid MLIR
- ✅ Lowering produces correct scf.for loop structures
- ✅ State management works across timesteps (memref-based)
- ✅ Integration with field operations functional
- ✅ Compilation time remains <1s for typical flows
- ✅ Comprehensive test coverage
- ✅ Complete documentation and examples

**Production Code:**
- ~2,500 lines of production code added
- 6 temporal operations implemented
- Complete lowering infrastructure
- Full compiler integration

**Ready for Phase 4**: Agent Operations (spawning, behavior trees, property updates)

---

## Phase 4: JIT Compilation (Months 10-12)

### Goals
- Implement JIT execution engine
- Support native code generation
- Benchmark and optimize

### JIT Engine Architecture

```python
from mlir.execution_engine import ExecutionEngine

class KairoJIT:
    """JIT compiler for Morphogen programs."""

    def __init__(self, module: ir.Module):
        self.module = module
        self.engine = None

    def compile(self):
        """Compile module to native code."""
        # Lower to LLVM dialect
        pm = PassManager.parse("builtin.module(convert-to-llvm)")
        pm.run(self.module)

        # Create execution engine
        self.engine = ExecutionEngine(self.module)

    def invoke(self, func_name: str, *args):
        """Execute compiled function."""
        return self.engine.invoke(func_name, *args)
```

---

## Testing Strategy

### Unit Tests
- Test each dialect operation individually
- Verify lowering passes produce correct IR
- Validate optimization passes preserve semantics

### Integration Tests
- End-to-end compilation of simple Morphogen programs
- Compare JIT execution results with interpreter
- Benchmark performance gains

### Performance Targets
- **Field operations**: 10-100x speedup over Python
- **Temporal evolution**: Native execution speed
- **Compilation time**: < 1s for typical programs

---

## Migration Path

### Backward Compatibility
- Keep old `ir_builder.py` and `optimizer.py` for v0.6.0 compatibility
- Mark as deprecated with clear migration notes
- Provide side-by-side comparison in docs

### Feature Flags
```python
# config.py
MLIR_BACKEND = "real"  # or "legacy" for old text-based backend
```

---

## Dependencies

### Core Requirements
- `mlir` (via mlir-wheels or built from source)
- `numpy` (for array operations)
- `llvmlite` (for LLVM IR inspection)

### Optional
- `numba` (for comparison benchmarks)
- `torch` (for torch-mlir integration)

---

## Documentation Deliverables

1. **User Guide**: How to use MLIR-compiled Morphogen
2. **Developer Guide**: How to add new dialect operations
3. **Migration Guide**: Porting from v0.6.0 to v0.7.0
4. **Performance Guide**: Optimization best practices

---

## Success Metrics

- ✅ Successfully compile and execute simple field operation
- ✅ 10x+ performance improvement over interpreter
- ✅ All v0.6.0 examples work with MLIR backend
- ✅ Documentation complete and accurate
- ✅ Tests passing with >90% coverage

---

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| MLIR Python bindings unstable | High | Pin specific version, contribute fixes upstream |
| Custom dialects complex | Medium | Start with simple ops, iterate |
| Performance not meeting goals | Medium | Profile early, optimize incrementally |
| Integration breaks existing code | Low | Feature flags, thorough testing |

---

## Timeline

- **Month 1-3**: Foundation + PoC
- **Month 4-6**: Field operations dialect
- **Month 7-9**: Temporal execution
- **Month 10-12**: JIT compilation + optimization
- **Month 12+**: Refinement, documentation, testing

---

## References

- [MLIR Language Reference](https://mlir.llvm.org/docs/LangRef/)
- [MLIR Python Bindings](https://mlir.llvm.org/docs/Bindings/Python/)
- [Toy Tutorial](https://mlir.llvm.org/docs/Tutorials/Toy/)
- [IRDL Dialect Definition](https://mlir.llvm.org/docs/Dialects/IRDL/)
